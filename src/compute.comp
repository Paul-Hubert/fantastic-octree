#version 450
#extension GL_ARB_separate_shader_objects : enable

layout (local_size_x = 8, local_size_y = 8) in;
layout (binding = 0, rgba8) uniform writeonly image2D resultImage;

layout (binding = 1) uniform Transform {
    mat4 viewinvproj;
    vec3 pos;
} ubo;

struct Chunk {
    float ptrs[8];
    uint leaves;
};

layout(std430, binding = 2) buffer Chunks {
    Chunk chunks[];
};

const int CHUNK_SIZE = 64;
const int MAX_DEPTH = 5;

/*

float getDensity(vec3 position) {
    if(position.x<0. || position.x>CHUNK_SIZE || position.y<0. || position.y>CHUNK_SIZE || position.z<0. || position.z>CHUNK_SIZE) {
        return 1.;
    }
    Chunk curr = chunks[0];
    vec3 off = vec3(0.);
    for(int depth = 0;; depth++) {
        float halfsize = pow(2, MAX_DEPTH - depth);
        ivec3 np = ivec3(position.x-off.x>=halfsize, position.y-off.y>=halfsize, position.z-off.z>=halfsize);
        int ind = np.x + np.y*4 + np.z*2;
        if(((curr.leaves >> ind) & 1) == 1) {
            curr = chunks[int(curr.ptrs[ind])];
            off += np * halfsize;
        } else {
            return curr.ptrs[ind];
        }
    }
}

*/

void main() {

    vec2 size = vec2(imageSize(resultImage));
    if(gl_GlobalInvocationID.x >= size.x || gl_GlobalInvocationID.y >= size.y) return;

    vec3 ray = normalize((ubo.viewinvproj * vec4(gl_GlobalInvocationID.x / size.x *  -2. + 1., gl_GlobalInvocationID.y / size.y * -2. + 1., 0., 1.)).xyz);

    vec3 position = ubo.pos;
    
    {
        vec3 tmin = (vec3(0)          - position)/ray;
        vec3 tmax = (vec3(CHUNK_SIZE) - position)/ray;
        
        float mint = max(max( min(tmin.x, tmax.x), min(tmin.y, tmax.y)), min(tmin.z, tmax.z) );
        float maxt = min(min( max(tmin.x, tmax.x), max(tmin.y, tmax.y)), max(tmin.z, tmax.z) );
        
        if(maxt < mint || maxt < 0.) {
            imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(1,1,0,1));
            return;
        }
        position += ray*max(mint, 0.);
    }

    
    float density = 1.;
    Chunk stack[MAX_DEPTH];
    int indices[MAX_DEPTH];
    for(int i = 0; i<MAX_DEPTH; i++) {
        indices[i] = 8;
    }

    int depth = 0;
    vec3 off = vec3(0.);
    stack[0] = chunks[0];
    
    int step = 0;
    do {
        step++;
        if(step >= 1000) {
            break;
        }
        float halfsize = pow(2, MAX_DEPTH - depth);
        ivec3 np = ivec3(position.x-off.x>=halfsize, position.y-off.y>=halfsize, position.z-off.z>=halfsize);
        int ind = np.x + np.y*4 + np.z*2;
        off += np * halfsize;

        if(((stack[depth].leaves >> ind) & 1) == 1) {
            if(ind != indices[depth]) {
                stack[depth+1] = chunks[int(stack[depth].ptrs[ind])];
                indices[depth+1] = 8;
            }
            indices[depth] = ind;
            depth++;
        } else {
            density = stack[depth].ptrs[ind];
            if(density <= 0.) {
                break;
            }
            vec3 tmin = (off - position)/ray;
            vec3 tmax = ((off + halfsize) - position)/ray;
            position += ray * (min(min( max(tmin.x, tmax.x), max(tmin.y, tmax.y)), max(tmin.z, tmax.z)) + 0.01);
            depth = 0;
        }
        
    } while(true);
    
    imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(position/64.,1));
    
}
