#version 450
#extension GL_ARB_separate_shader_objects : enable

layout (local_size_x = 64) in;

const vec3 offsets[24] = {
    // 0
    vec3(0,0,0),
    vec3(1,0,0),
    // 1
    vec3(1,0,0),
    vec3(1,0,1),
    // 2
    vec3(1,0,1),
    vec3(0,0,1),
    // 3
    vec3(0,0,1),
    vec3(0,0,0),
    // 4
    vec3(0,1,0),
    vec3(1,1,0),
    // 5
    vec3(1,1,0),
    vec3(1,1,1),
    // 6
    vec3(1,1,1),
    vec3(0,1,1),
    // 7
    vec3(0,1,1),
    vec3(0,1,0),
    // 8
    vec3(0,0,0),
    vec3(0,1,0),
    // 9
    vec3(1,0,0),
    vec3(1,1,0),
    // 10
    vec3(1,0,1),
    vec3(1,1,1),
    // 11
    vec3(0,0,1),
    vec3(0,1,1)
};

const int CHUNK_SIZE = 64;


struct Cube {
    vec4 pos;
};

layout(std430, binding = 0) buffer Cubes {
    Cube cubes[];
};

struct Value {
    float density;
};

layout(std430, binding = 1) buffer Values {
    Value values[];
};

struct Triangles {
    vec3 tris[15];
};

layout(std430, binding = 2) buffer Tris {
    float tril[];
};

layout(binding = 3) uniform isamplerBuffer triTable;

void main() {
    
    Cube cube = cubes[gl_GlobalInvocationID.x];
    
    //Triangles t;
    
    for(int i = 0; i<15; i++) {
        int edge = texelFetch(triTable, int(cube.pos.w) * 16 + i).r * 2;
        vec3 a1 = cube.pos.xyz + offsets[edge], a2 = cube.pos.xyz + offsets[edge+1];
        float density1 = values[int(a1.x * CHUNK_SIZE*CHUNK_SIZE + a1.y * CHUNK_SIZE + a1.z)].density;
        vec3 vertex = edge >= 0 ? 5.*mix(a1, a2, (-density1)/(values[int(a2.x * CHUNK_SIZE*CHUNK_SIZE + a2.y * CHUNK_SIZE + a2.z)].density - density1)) : vec3(0);
        tril[(gl_GlobalInvocationID.x*15+i)*3] = vertex.x;
        tril[(gl_GlobalInvocationID.x*15+i)*3+1] = vertex.y;
        tril[(gl_GlobalInvocationID.x*15+i)*3+2] = vertex.z;
    }
    
    //tril[gl_GlobalInvocationID.x] = t;
    
}





