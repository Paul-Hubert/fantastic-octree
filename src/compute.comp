#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_KHR_shader_subgroup_quad: enable
#extension GL_KHR_shader_subgroup_vote: enable

layout (local_size_x = 8, local_size_y = 8) in;
layout (binding = 0, rgba8) uniform writeonly image2D resultImage;

layout (binding = 1) uniform Transform {
    mat4 viewinvproj;
    vec3 pos;
} ubo;

struct Chunk {
    float ptrs[8];
    uint leaves;
};

layout(std430, binding = 2) buffer Chunks {
    Chunk chunks[];
};

const int CHUNK_SIZE = 64;
const int MAX_DEPTH = 5;

const float SPREAD = 3.;

float getDensity(vec3 position) {
    if(position.x<0. || position.x>CHUNK_SIZE || position.y<0. || position.y>CHUNK_SIZE || position.z<0. || position.z>CHUNK_SIZE) {
        return 1.;
    }
    Chunk curr = chunks[0];
    vec3 off = vec3(0.);
    for(int depth = 0;; depth++) {
        float halfsize = pow(2, MAX_DEPTH - depth);
        ivec3 np = ivec3(position.x-off.x>=halfsize, position.y-off.y>=halfsize, position.z-off.z>=halfsize);
        int ind = np.x + np.y*4 + np.z*2;
        if(((curr.leaves >> ind) & 1) == 1) {
            curr = chunks[int(curr.ptrs[ind])];
            off += np * halfsize;
        } else {
            return curr.ptrs[ind];
        }
    }
}

void main() {

    vec2 size = vec2(imageSize(resultImage));
    if(gl_GlobalInvocationID.x >= size.x || gl_GlobalInvocationID.y >= size.y) return;

    vec3 ray = normalize((ubo.viewinvproj * vec4(gl_GlobalInvocationID.x / size.x *  -2. + 1., gl_GlobalInvocationID.y / size.y * -2. + 1., 0., 1.)).xyz);

    vec3 position = ubo.pos;

    float len = 0., density = 1., lastdensity = 1.;
    do {
        len+=1;
        position+=ray*1;
        if(position.x<0. || position.x>CHUNK_SIZE || position.y<0. || position.y>CHUNK_SIZE || position.z<0. || position.z>CHUNK_SIZE) {
            if(len>=100.) {
                imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(1,1,0,1));
                return;
            }
            continue;
        }

        //density = getDensity((SPREAD+1)*position - SPREAD*subgroupQuadSwapDiagonal(position) + ray*1);
        //density = ((5.*density + 2.*subgroupQuadSwapHorizontal(density) + 2.*subgroupQuadSwapVertical(density) + 1.*subgroupQuadSwapDiagonal(density)) / 10. + lastdensity)/2.;


        Chunk curr = chunks[0];
        vec3 off = vec3(0.);
        for(int depth = 0;; depth++) {
            float halfsize = pow(2, MAX_DEPTH - depth);
            ivec3 np = ivec3(position.x-off.x>=halfsize, position.y-off.y>=halfsize, position.z-off.z>=halfsize);
            int ind = np.x + np.y*4 + np.z*2;
            if(((curr.leaves >> ind) & 1) == 1) {
                curr = chunks[int(curr.ptrs[ind])];
                off += np * halfsize;
            } else {
                density = curr.ptrs[ind];
                off += np + vec3(0.5);
                break;
            }
        }


        ivec3 np = ivec3(position.x-off.x>=0, position.y-off.y>=0, position.z-off.z>=0)*2-ivec3(1);
        density = ((density + getDensity(vec3(off.x + np.x, off.y, off.z)) + getDensity(vec3(off.x, off.y + np.y, off.z)) + getDensity(vec3(off.x, off.y, off.z + np.z))) / 4.);

        if(lastdensity > 0.) lastdensity = density;

    } while(subgroupAny(density > 0.));
    
    imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(-density/10.));
    
}
