#version 450
#extension GL_ARB_separate_shader_objects : enable

layout (local_size_x = 8, local_size_y = 8) in;
layout (binding = 0, rgba8) uniform writeonly image2D resultImage;

layout (binding = 1) uniform Transform {
    mat4 viewinvproj;
    vec3 pos;
} ubo;

struct Chunk {
    float ptrs[8];
    uint leaves;
};

layout(std430, binding = 2) buffer Chunks {
    Chunk chunks[];
};

const int CHUNK_SIZE = 64;
const int MAX_DEPTH = 5;

shared vec4 values[64]; // local size x*y*z

float getDensity(vec3 position) {
    Chunk curr = chunks[0];
    vec3 off = vec3(0.);
    for(int depth = 0;; depth++) {
        float halfsize = pow(2, MAX_DEPTH - depth);
        ivec3 np = ivec3(position.x-off.x>=halfsize, position.y-off.y>=halfsize, position.z-off.z>=halfsize);
        int ind = np.x + np.y*4 + np.z*2;
        if(((curr.leaves >> ind) & 1) == 1) {
            curr = chunks[int(curr.ptrs[ind])];
            off += np * halfsize;
        } else {
            return curr.ptrs[ind];
        }
    }
}

void main() {

    vec2 size = vec2(imageSize(resultImage));
    if(gl_GlobalInvocationID.x >= size.x || gl_GlobalInvocationID.y >= size.y) return;

    vec3 ray = normalize((ubo.viewinvproj * vec4(gl_GlobalInvocationID.x / size.x *  -2. + 1., gl_GlobalInvocationID.y / size.y * -2. + 1., 0., 1.)).xyz);

    vec3 position = ubo.pos;

    vec3 up = vec3(0);
    vec3 left = cross(ray, vec3(0,1,0));

    float len = 0., density = 1.;
    do {
        len+=.1;
        position+=ray*.1;
        
        if(position.x<0. || position.x>CHUNK_SIZE || position.y<0. || position.y>CHUNK_SIZE || position.z<0. || position.z>CHUNK_SIZE) {
            if(len>=100.) {
                imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(1,1,0,1));
                return;
            }
            values[gl_LocalInvocationID.x*gl_WorkGroupSize.y+gl_LocalInvocationID.y] = vec4(position, 1.0);
            continue;
        }

        //vec3 cpos = position + left * (gl_LocalInvocationID.x - 4)*4. + vec3(0,1,0) * (gl_LocalInvocationID.y - 4)*4.;
        values[gl_LocalInvocationID.x*gl_WorkGroupSize.y+gl_LocalInvocationID.y] = vec4(position, getDensity(position));
        memoryBarrierShared();


        density = 0.;
        float sum = 0.;
        for(int i = 0; i<64; i+=4) {
            float dist2 = exp(1. - dot(values[i].xyz-position,values[i].xyz-position)/10.);
            density += dist2 * values[i].w;
            sum += dist2;
        }

        density/=sum;


    } while(density > 0.);
    
    imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(-density/10.));
    
}
