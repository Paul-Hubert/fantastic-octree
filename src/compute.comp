#version 450
#extension GL_ARB_separate_shader_objects : enable

layout (local_size_x = 8, local_size_y = 8) in;
layout (binding = 0, rgba8) uniform writeonly image2D resultImage;

layout (binding = 1) uniform Transform {
    mat4 viewinvproj;
    vec3 pos;
} ubo;

struct Chunk {
    float ptrs[8];
    uint leaves;
};

layout(std430, binding = 2) buffer Chunks {
    Chunk chunks[];
};

const int CHUNK_SIZE = 64;
const int MAX_DEPTH = 5;

/*

float getDensity(vec3 position) {
    if(position.x<0. || position.x>CHUNK_SIZE || position.y<0. || position.y>CHUNK_SIZE || position.z<0. || position.z>CHUNK_SIZE) {
        return 1.;
    }
    Chunk curr = chunks[0];
    vec3 off = vec3(0.);
    for(int depth = 0;; depth++) {
        float halfsize = pow(2, MAX_DEPTH - depth);
        ivec3 np = ivec3(position.x-off.x>=halfsize, position.y-off.y>=halfsize, position.z-off.z>=halfsize);
        int ind = np.x + np.y*4 + np.z*2;
        if(((curr.leaves >> ind) & 1) == 1) {
            curr = chunks[int(curr.ptrs[ind])];
            off += np * halfsize;
        } else {
            return curr.ptrs[ind];
        }
    }
}

*/

void main() {

    vec2 size = vec2(imageSize(resultImage));
    if(gl_GlobalInvocationID.x >= size.x || gl_GlobalInvocationID.y >= size.y) return;

    vec3 ray = normalize((ubo.viewinvproj * vec4(gl_GlobalInvocationID.x / size.x *  -2. + 1., gl_GlobalInvocationID.y / size.y * -2. + 1., 0., 1.)).xyz);

    vec3 position = ubo.pos;
    
    {
        vec3 tmin = (vec3(0)          - position)/ray;
        vec3 tmax = (vec3(CHUNK_SIZE) - position)/ray;
        
        float mint = max(max( min(tmin.x, tmax.x), min(tmin.y, tmax.y)), min(tmin.z, tmax.z) );
        float maxt = min(min( max(tmin.x, tmax.x), max(tmin.y, tmax.y)), max(tmin.z, tmax.z) );
        
        if(maxt < mint || maxt < 0.) {
            imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(1,1,0,1));
            return;
        }
        position += ray*max(mint, 0.);
    }

    
    float density = 1.;
    Chunk curr = chunks[0];

    int depth = 0;
    vec3 off = vec3(0.);
    float halfsize;

    do {
        halfsize = pow(2, MAX_DEPTH - depth);
        ivec3 np = ivec3(position.x-off.x>=halfsize, position.y-off.y>=halfsize, position.z-off.z>=halfsize);
        int ind = np.x + np.y*4 + np.z*2;
        off += np * halfsize;
        if(((curr.leaves >> ind) & 1) == 1) {
            curr = chunks[int(curr.ptrs[ind])];
            depth++;
        } else {
            density = curr.ptrs[ind];
            vec3 tmin = (off - position)/ray;
            vec3 tmax = (off + halfsize - position)/ray;
            if(density <= 0.) {
                break;
            }
            position += ray * (min(min( max(tmin.x, tmax.x), max(tmin.y, tmax.y)), max(tmin.z, tmax.z)) + 0.001);
            if(position.x<0. || position.x>CHUNK_SIZE || position.y<0. || position.y>CHUNK_SIZE || position.z<0. || position.z>CHUNK_SIZE) {
                imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(1,1,0,1));
                return;
            }
            curr = chunks[0];
            off = vec3(0.);
            depth = 0;
        }
        
    } while(true);
    
    float realdensity = density;
    ray = normalize(vec3(1.0,1.0,2.0));
    vec3 tmin = (off - position)/ray;
    vec3 tmax = (off + halfsize - position)/ray;
    position += ray * (min(min( max(tmin.x, tmax.x), max(tmin.y, tmax.y)), max(tmin.z, tmax.z)) + 0.001);
    curr = chunks[0];
    off = vec3(0.);
    depth = 0;

    do {
        halfsize = pow(2, MAX_DEPTH - depth);
        ivec3 np = ivec3(position.x-off.x>=halfsize, position.y-off.y>=halfsize, position.z-off.z>=halfsize);
        int ind = np.x + np.y*4 + np.z*2;
        off += np * halfsize;
        if(((curr.leaves >> ind) & 1) == 1) {
            curr = chunks[int(curr.ptrs[ind])];
            depth++;
        } else {
            density = curr.ptrs[ind];
            vec3 tmin = (off - position)/ray;
            vec3 tmax = (off + halfsize - position)/ray;
            curr = chunks[0];
            off = vec3(0.);
            depth = 0;
            if(density <= 0.) {
                break;
            }
            position += ray * (min(min( max(tmin.x, tmax.x), max(tmin.y, tmax.y)), max(tmin.z, tmax.z)) + 0.001);
            if(position.x<0. || position.x>CHUNK_SIZE || position.y<0. || position.y>CHUNK_SIZE || position.z<0. || position.z>CHUNK_SIZE) {
                break;
            }

        }

    } while(true);

    imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(vec3(-(realdensity - 1.0)/10.) * (density > 0. ? 1 : 0), 1));
    
}
